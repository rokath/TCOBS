// Package tcobs_test contains TCOBS whitebox tests.
package tcobs_test

import (
	"bytes"
	"fmt"
	"math/rand"
	"tcobs/pkg/tcobs"
	"testing"

	"github.com/tj/assert"
)

type testTable []struct {
	dec []byte
	enc []byte
}

var testData = testTable{

	{[]byte{0x02, 0x01, 0xff, 0x01, 0x01, 0x02, 0x02, 0x01, 0xff, 0x01, 0x01, 0x01, 0x01, 0x01},
		[]byte{0x02, 0x01, 0xff, 0x01, 0x01, 0x02, 0x02, 0x01, 0xff, 0x01, 0xaa, 0x18}},
	//                                                                     No10, R4o0

	{[]byte{0x01, 0x02, 0x00, 0x00, 0xff, 0x02, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x01, 0xff, 0x01, 0x01, 0x02, 0x02, 0x01, 0xff, 0x01, 0x01, 0x01, 0x01, 0x01},
		[]byte{0x01, 0x02, 0x42, 0xff, 0x02, 0xff, 0x01, 0x64, 0x02, 0x01, 0xff, 0x01, 0x01, 0x02, 0x02, 0x01, 0xff, 0x01, 0xaa, 0x18}},
	//                     Z2o2                          Z3o4                                                              No10  R4o0

	{[]byte{}, []byte{}},

	{[]byte{0}, []byte{0x20}},
	{[]byte{0, 0xAA}, []byte{0x20, 0xAA, 0xA1}},
	{[]byte{0, 0xFF}, []byte{0x20, 0xFF, 0xA1}},

	{[]byte{0, 0}, []byte{0x40}},
	{[]byte{0, 0, 0xAA}, []byte{0x40, 0xAA, 0xA1}},
	{[]byte{0, 0, 0xFF}, []byte{0x40, 0xFF, 0xA1}},

	{[]byte{0, 0, 0}, []byte{0x60}},
	{[]byte{0, 0, 0, 0xAA}, []byte{0x60, 0xAA, 0xA1}},
	{[]byte{0, 0, 0, 0xFF}, []byte{0x60, 0xFF, 0xA1}},

	{[]byte{0, 0, 0, 0}, []byte{0x60, 0x20}},

	{[]byte{0, 0, 0, 0, 0}, []byte{0x60, 0x40}},
	{[]byte{0, 0, 0, 0, 0, 0xFF}, []byte{0x60, 0x40, 0xFF, 0xA1}},
	{[]byte{0, 0, 0, 0, 0, 0xAA}, []byte{0x60, 0x40, 0xAA, 0xA1}},

	{[]byte{0, 0, 0, 0, 0, 0, 0xFF}, []byte{0x60, 0x60, 0xFF, 0xA1}},
	{[]byte{0, 0, 0, 0, 0, 0xAA, 0xFF, 0xFF, 0xAA}, []byte{0x60, 0x40, 0xAA, 0xC1, 0xAA, 0xA1}},

	{[]byte{0xAA, 0xAA}, []byte{0xAA, 0xAA, 0xA2}},
	{[]byte{0xAA, 0xBB}, []byte{0xAA, 0xBB, 0xA2}},

	{[]byte{0xFF}, []byte{0xFF, 0xA1}},
	{[]byte{0xFF, 0x00}, []byte{0xFF, 0x21}},
	{[]byte{0xFF, 0xAA}, []byte{0xFF, 0xAA, 0xA2}},

	{[]byte{0xFF, 0xFF}, []byte{0xC0}},
	{[]byte{0xFF, 0xFF, 0x00}, []byte{0xC0, 0x20}},
	{[]byte{0xFF, 0xFF, 0xAA}, []byte{0xC0, 0xAA, 0xA1}},

	{[]byte{0xFF, 0xFF, 0xFF}, []byte{0xE0}},
	{[]byte{0xFF, 0xFF, 0xFF, 0x00}, []byte{0xE0, 0x20}},
	{[]byte{0xFF, 0xFF, 0xFF, 0xAA}, []byte{0xE0, 0xAA, 0xA1}},

	{[]byte{0xFF, 0xFF, 0xFF, 0xFF}, []byte{0x80}},
	{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0x00}, []byte{0x80, 0x20}},
	{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xAA}, []byte{0x80, 0xAA, 0xA1}},

	{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, []byte{0x80, 0xFF, 0xA1}},
	{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00}, []byte{0x80, 0xFF, 0x21}},
	{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xAA}, []byte{0x80, 0xFF, 0xAA, 0xA2}},

	{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, []byte{0x80, 0xC0}},
	{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xAA, 0xFF, 0xFF}, []byte{0x80, 0xAA, 0xC1}},
	{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF}, []byte{0x80, 0x20, 0xC0}},

	{[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xAA, 0xFF, 0xFF}, []byte{0x80, 0xFF, 0xAA, 0xC2}},

	{[]byte{0xAA}, []byte{0xAA, 0xA1}},
	{[]byte{0xAA, 0xAA}, []byte{0xAA, 0xAA, 0xA2}},
	{[]byte{0xAA, 0xAA, 0xAA}, []byte{0xAA, 0x09}},             // AA R2
	{[]byte{0xAA, 0xAA, 0xAA, 0xAA}, []byte{0xAA, 0x11}},       // AA R3
	{[]byte{0xAA, 0xAA, 0xAA, 0xAA, 0xAA}, []byte{0xAA, 0x19}}, // AA R4
	{[]byte{0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA}, []byte{0xAA, 0x19, 0xAA, 0xA1}},
	{[]byte{0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA}, []byte{0xAA, 0x19, 0xAA, 0xAA, 0xA2}},

	{[]byte{0xAA, 0x00}, []byte{0xAA, 0x21}},
	{[]byte{0xAA, 0xAA, 0x00}, []byte{0xAA, 0xAA, 0x22}},

	{[]byte{0, 2, 2, 2, 0, 1, 0, 255, 255, 255, 1, 2, 1, 0, 255, 1, 2, 0, 0, 1, 2, 1, 255, 1, 2, 2, 2, 255, 1, 2, 0, 255, 2, 2, 0},
		[]byte{0x20, 0x2, 0x9, 0x20, 0x1, 0x21, 0xe0, 0x1, 0x2, 0x1, 0x23, 0xff, 0x1, 0x2, 0x43, 0x1, 0x2, 0x1, 0xff, 0x1, 0x2, 0xe, 0xff, 0x1, 0x2, 0x23, 0xff, 0x2, 0x2, 0x23}},

	{[]byte{0xFF, 0x02, 0x02, 0x00}, []byte{0xFF, 0x02, 0x02, 0x23}},
	{[]byte{0xFF, 0x02, 0x02, 0x00, 0xFF}, []byte{0xFF, 0x02, 0x02, 0x23, 0xFF, 0xA1}},

	{[]byte{0, 2, 2, 2, 0, 1, 0, 255, 255, 255, 1, 2, 1, 0, 255, 1, 2, 0, 0, 1, 2, 1, 255, 1, 2, 2, 2, 255, 1, 2, 0, 255, 2, 2, 0, 255},
		[]byte{0x20, 0x2, 0x9, 0x20, 0x1, 0x21, 0xe0, 0x1, 0x2, 0x1, 0x23, 0xff, 0x1, 0x2, 0x43, 0x1, 0x2, 0x1, 0xff, 0x1, 0x2, 0xe, 0xff, 0x1, 0x2, 0x23, 0xff, 0x2, 0x2, 0x23, 0xFF, 0xA1}},
}

// TestTCOBSEncode checks if decoded testData lead to the matching encoded testData.
func TestCEncode(t *testing.T) {
	for _, k := range testData {
		enc := make([]byte, 40000)
		n := tcobs.CEncode(enc, k.dec)
		enc = enc[:n]
		assert.Equal(t, k.enc, enc)
	}
}

// TestTCOBSDecode checks if encoded testData lead to the matching unencoded testData.
func TestDecode(t *testing.T) {
	b := make([]byte, 40000)
	for _, k := range testData {
		n, e := tcobs.Decode(b, k.enc) // func TCOBSDecode(d, in []byte) (n int, e error) {
		assert.True(t, e == nil)
		assert.True(t, n <= len(b))
		dec := b[len(b)-n:]
		assert.Equal(t, k.dec, dec)
	}
}

// TestCEncodeDecode12 tests on generated random byte numbers 0xFF, 0x00, 0x01 and 0x02 for random length 0-32767.
func TestCEncodeDecode12(t *testing.T) {
	max := 32768
	for i := 0; i < 10000; i++ {
		length := rand.Intn(max)
		datBuf := make([]byte, max)
		encBuf := make([]byte, 2*max) // max 1 + (1+1/32)*len) ~= 1.04 * len
		decBuf := make([]byte, 2*max) // max 1 + (1+1/32)*len) ~= 1.04 * len
		for i := 0; i < length; i++ {
			b := uint8(rand.Intn(4)) - 1 // -1, 0, 1 2
			datBuf[i] = b
		}
		dat := datBuf[:length]
		n := tcobs.CEncode(encBuf, dat)
		enc := encBuf[:n]
		assert.False(t, bytes.Contains(enc, []byte{0}))
		n, e := tcobs.Decode(decBuf, enc)
		assert.True(t, e == nil)
		dec := decBuf[len(decBuf)-n:]
		assert.Equal(t, dat, dec)
	}
}

// TestCEncodeDecode1 tests on generated random byte numbers 0xFF, 0x00 and 0x01 for random length 0-32767.
func TestEncodeDecode1(t *testing.T) {
	max := 32768
	for i := 0; i < 10000; i++ {
		length := rand.Intn(max)
		datBuf := make([]byte, max)
		encBuf := make([]byte, 2*max) // max 1 + (1+1/32)*len) ~= 1.04 * len
		decBuf := make([]byte, 2*max) // max 1 + (1+1/32)*len) ~= 1.04 * len
		for i := 0; i < length; i++ {
			b := uint8(rand.Intn(3)) - 1 // -1, 0, 1
			datBuf[i] = b
		}
		dat := datBuf[:length]
		fmt.Println()
		n := tcobs.CEncode(encBuf, dat)
		enc := encBuf[:n]
		assert.False(t, bytes.Contains(enc, []byte{0}))
		n, e := tcobs.Decode(decBuf, enc)
		assert.True(t, e == nil)
		dec := decBuf[len(decBuf)-n:]
		assert.Equal(t, dat, dec)
	}
}

// TestCEncodeDecode256 tests on generated random byte numbers for random length 0-32767.
func TestCEncodeDecode256(t *testing.T) {
	max := 32768
	for i := 0; i < 10000; i++ {
		length := rand.Intn(max)
		datBuf := make([]byte, max)
		encBuf := make([]byte, 2*max) // max 1 + (1+1/32)*len) ~= 1.04 * len
		decBuf := make([]byte, 2*max) // max 1 + (1+1/32)*len) ~= 1.04 * len
		for i := 0; i < length; i++ {
			b := uint8(rand.Intn(256)) // 0, ..., 0xFF
			datBuf[i] = b
		}
		dat := datBuf[:length]
		fmt.Println()
		n := tcobs.CEncode(encBuf, dat)
		enc := encBuf[:n]
		assert.False(t, bytes.Contains(enc, []byte{0}))
		n, e := tcobs.Decode(decBuf, enc)
		assert.True(t, e == nil)
		dec := decBuf[len(decBuf)-n:]
		assert.Equal(t, dat, dec)
	}
}

//  // PrintAsGoCode prints x for easy copy & paste into test table.
//  func PrintAsGoCode(x []byte) {
//  	fmt.Print("[]byte{")
//  	for _, b := range x {
//  		fmt.Printf("0x%02x, ", b)
//  	}
//  	fmt.Println("}")
//  }
