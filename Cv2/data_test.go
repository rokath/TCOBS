package tcobsv2_test

import (
	"testing"

	tcobs "github.com/rokath/tcobs/Cv2"
	"github.com/stretchr/testify/assert"
)

// TestTableCEncode checks if decoded testData lead to the matching encoded testData.
func TestTableCEncode(t *testing.T) {
	for _, k := range testData {
		enc := make([]byte, 40000)
		n := tcobs.CEncode(enc, k.dec)
		enc = enc[:n]
		assert.Equal(t, k.enc, enc)
	}
}

// TestTableCDecode checks if decoded testData lead to the matching encoded testData.
func TestTableCDecode(t *testing.T) {
	for _, k := range testData {
		dec := make([]byte, 40000)
		n := tcobs.CDecode(dec, k.enc)
		dec = dec[len(dec)-n:]
		assert.Equal(t, k.dec, dec)
	}
}

const testBufferSize = 64 * 1024

type testTable []struct {
	dec []byte
	enc []byte
}

var testData = testTable{
	{[]byte{0xaa, 0xff}, []byte{0xaa, 0xff, 0x02}},
	{[]byte{0xaa, 0xbb, 0xff}, []byte{0xaa, 0xbb, 0xff, 0x03}},
	{[]byte{}, []byte{}},
	{[]byte{0}, []byte{0x20}},
	{[]byte{0, 0}, []byte{0x60}},
	{[]byte{0, 0, 0}, []byte{0x50}},
	{[]byte{0, 0, 0, 0}, []byte{0xb0}},
	{[]byte{0, 0, 0, 0, 0}, []byte{0x20, 0x20}},
	{[]byte{9}, []byte{9, 0x01}},
	{[]byte{9, 9}, []byte{9, 9, 0x02}},
	{[]byte{9, 9, 9}, []byte{9, 0x81}},
	{[]byte{9, 9, 9, 9}, []byte{9, 0x41}},
	{[]byte{9, 9, 9, 9, 9}, []byte{9, 0xa1}},
	{[]byte{9, 9, 9, 9, 9, 9}, []byte{9, 0x81, 0x80}},
	{[]byte{0xff, 0xff}, []byte{0xc0}},
	{[]byte{0xff, 0xff, 0xff}, []byte{0xe0}},
	{[]byte{0xff, 0xff, 0xff, 0xff}, []byte{0xf0}},
	{[]byte{0xff, 0xff, 0xff, 0xff, 0xff}, []byte{0xff, 0xff}},
	{[]byte{0, 0xaa}, []byte{0x20, 0xaa, 0x01}},
	{[]byte{0, 0xff}, []byte{0x20, 0xff}},
	{[]byte{0, 0, 0xaa}, []byte{0x60, 0xaa, 0x01}},
	{[]byte{0, 0, 0xff}, []byte{0x60, 0xff}},
	{[]byte{0, 0, 0, 0xaa}, []byte{0x50, 0xaa, 0x01}},
	{[]byte{0, 0, 0, 0xff}, []byte{0x50, 0xff}},
	{[]byte{0xaa, 0xaa}, []byte{0xaa, 0xaa, 0x02}},
	{[]byte{0xff, 0x00}, []byte{0xff, 0x21}},
	{[]byte{0xff, 0xaa}, []byte{0xff, 0xaa, 0x02}},
	{[]byte{0xff, 0xff, 0xaa}, []byte{0xc0, 0xaa, 0x01}},
	{[]byte{0xff, 0xff, 0xff, 0xaa}, []byte{0xe0, 0xaa, 0x01}},
	{[]byte{0xff, 0xff, 0xff, 0xff, 0xaa}, []byte{0xf0, 0xaa, 0x01}},
	{[]byte{0xff, 0xff, 0xff, 0xff, 0xaa, 0xff, 0xff}, []byte{0xf0, 0xaa, 0xc1}},
	{[]byte{0xaa, 0xaa, 0x00}, []byte{0xaa, 0xaa, 0x22}},
	{[]byte{0xaa, 0x00}, []byte{0xaa, 0x21}},
	{[]byte{0xaa, 0xbb}, []byte{0xaa, 0xbb, 0x02}},
	{[]byte{0xff, 0xff, 0x00}, []byte{0xc0, 0x20}},
	{[]byte{0, 0, 0, 0, 0, 0xaa, 0xff, 0xff, 0xaa}, []byte{0x20, 0x20, 0xaa, 0xc1, 0xaa, 0x01}},
	{[]byte{0, 0, 0, 0, 0}, []byte{0x20, 0x20}},
	{[]byte{0, 0, 0, 0, 0, 0xff}, []byte{0x20, 0x20, 0xff}},
	{[]byte{0, 0, 0, 0, 0, 0xaa}, []byte{0x20, 0x20, 0xaa, 0x01}},
	{[]byte{0, 0, 0, 0, 0, 0, 0xff}, []byte{0x20, 0x60, 0xff}},
	{[]byte{0xaa, 0xaa, 0xaa, 0xaa, 0xaa}, []byte{0xaa, 0xa1}},
	{[]byte{0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa}, []byte{0xaa, 0x81, 0x80}},
	{[]byte{0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa}, []byte{0xaa, 0x81, 0x40}},
	{[]byte{0xff, 0xff, 0xff, 0x00}, []byte{0xe0, 0x20}},
	{[]byte{0xff, 0xff, 0xff, 0xff, 0x00}, []byte{0xf0, 0x20}},
	{[]byte{0xff, 0xff, 0xff, 0xff, 0xff}, []byte{0xff, 0xff}},
	{[]byte{0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff}, []byte{0xf0, 0x20, 0xc0}},
	{[]byte{0xff, 0x02, 0x02, 0x00}, []byte{0xff, 0x02, 0x02, 0x23}},
	{[]byte{0, 2, 2, 2, 0, 1, 0, 255, 255, 255, 1, 2, 1, 0, 255, 1, 2, 0, 0, 1, 2, 1, 255, 1, 2, 2, 2, 255, 1, 2, 0, 255, 2, 2, 0},
		[]byte{0x20, 0x2, 0x81, 0x20, 0x1, 0x21, 0xe0, 0x1, 0x2, 0x1, 0x23, 0xff, 0x1, 0x2, 0x63, 0x1, 0x2, 0x1, 0xff, 0x1, 0x2, 0x86, 0xff, 0x1, 0x2, 0x23, 0xff, 0x2, 0x2, 0x23},
	},
	{[]byte{0, 2, 2, 2, 0, 1, 0, 255, 255, 255, 1, 2, 1, 0, 255, 1, 2, 0, 0, 1, 2, 1, 255, 1, 2, 2, 2, 255, 1, 2, 0, 255, 2, 2, 0, 255},
		[]byte{0x20, 0x2, 0x81, 0x20, 0x1, 0x21, 0xe0, 0x1, 0x2, 0x1, 0x23, 0xff, 0x1, 0x2, 0x63, 0x1, 0x2, 0x1, 0xff, 0x1, 0x2, 0x86, 0xff, 0x1, 0x2, 0x23, 0xff, 0x2, 0x2, 0x23, 0xff},
	},
	{[]byte{0x02, 0x01, 0xff, 0x01, 0x01, 0x02, 0x02, 0x01, 0xff, 0x01, 0x01, 0x01, 0x01, 0x01},
		[]byte{0x2, 0x1, 0xff, 0x1, 0x1, 0x2, 0x2, 0x1, 0xff, 0x1, 0xaa},
	},
	{[]byte{0x01, 0x02, 0x00, 0x00, 0xff, 0x02, 0xff, 0x01, 0x00, 0x00, 0x00, 0x02, 0x01, 0xff, 0x01, 0x01, 0x02, 0x02, 0x01, 0xff, 0x01, 0x01, 0x01, 0x01, 0x01},
		[]byte{0x1, 0x2, 0x62, 0xff, 0x2, 0xff, 0x1, 0x54, 0x2, 0x1, 0xff, 0x1, 0x1, 0x2, 0x2, 0x1, 0xff, 0x1, 0xaa},
	},
	{[]byte{0xff}, []byte{0xff}},
	{[]byte{0xff, 0x02, 0x02, 0x00, 0xff}, []byte{0xff, 0x02, 0x02, 0x23, 0xff}},
	{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0x00}, []byte{0xff, 0xff, 0x20}},
	{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xaa}, []byte{0xff, 0xff, 0xaa, 0x01}},
	{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, []byte{0xff, 0xc0}},
	{[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xaa, 0xff, 0xff}, []byte{0xff, 0xff, 0xaa, 0xc1}},
}

// createEncodedStream concatenates all testData enc sequences with 0-delimiters into one byte slice.
func createEncodedStream() []byte {
	enc := make([]byte, 0, testBufferSize)
	for _, k := range testData {
		enc = append(enc, k.enc...)
		enc = append(enc, 0)
	}
	return enc
}
